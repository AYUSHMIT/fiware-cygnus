# <a name="top"></a>NGSIPostGISSink
Content:

* [Functionality](#section1)
    * [Mapping `NGSIEvent`s to PostgreSQL data structures](#section1.2)
        * [PostgreSQL databases naming conventions](#section1.2.1)
        * [PostgreSQL schemas naming conventions](#section1.2.2)
        * [PostgreSQL tables naming conventions](#section1.2.3)
* [Administration guide](#section2)
    * [Configuration](#section2.1)
* [Programmers guide](#section3)
* [Native types](#section4)

## <a name="section1"></a>Functionality
`com.iot.telefonica.cygnus.sinks.NGSIPostGISSink`, or simply `NGSIPostGISSink` is a sink designed to persist NGSI-like context data events within a [PostGIS server](https://postgis.net/) which is relational database extension of [PostgreSQL server](https://www.postgresql.org/) which allows store GIS objects (Geographic Information Systems). Usually, such a context data is notified by a [Orion Context Broker](https://github.com/telefonicaid/fiware-orion) instance, but could be any other system speaking the <i>NGSI language</i>.

Independently of the data generator, NGSI context data is always transformed into internal `NGSIEvent` objects at Cygnus sources. In the end, the information within these events must be mapped into specific PostgreSQL data structures.

For futher detail please refear to [`NGSIPostgreSQLSink`](/ngsi_postgresql_sink.md)
Basically PostGIS sink translates NGSI attribute value about geometry (geo:point, geo:json) to PostGIS format and insert it.


    geo:point ->  ST_SetSRID(ST_MakePoint())

    geo:json -> ST_GeomFromGeoJSON()

Colum should be provisioned as type [`geometry`](http://postgis.net/workshops/postgis-intro/geometries.html)

    CREATE TABLE myTable ( geom geometry );

[Top](#top)

### <a name="section1.2"></a>Mapping `NGSIEvent`s to PostgreSQL data structures

NOTE: by the moment this mapping functionality works only for Postgis sink. However, the same will be implemented for the Postgresql sink itself. In that moment probably this documentation will be moved to the Postgresql sink documentation (as that is the common place for documentation which applies to both sinks)

PostgreSQL organizes the data in schemas inside a database that contain tables of data rows. Such organization is exploited by `NGSIPostgreisSink` each time a `NGSIEvent` is going to be persisted.

[Top](#top)

#### <a name="section1.2.1"></a>PostgreSQL databases naming conventions
Previous to any operation with PostgreSQL you need to create the database to be used.

It must be said [PostgreSQL only accepts](https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) alphanumeric characters and the underscore (`_`). This leads to  certain [encoding](#section2.3.4) is applied depending on the `enable_encoding` configuration parameter.

PostgreSQL [databases name length](http://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) is limited to 63 characters.

The name of this databases depends on the configured data model (see the [Configuration](#section2.1) section for more details):

* Data model by entity database (`data_model=dm-by-entity-database`). For this datamodel the name of the database will be auto generated by the sink, this name will be the `fiware-service` found on the headers of the first request incoming to the sink.

* Data model by entity database schema (`data_model=dm-by-entity-database-schema`). For this datamodel the name of the database will be auto generated by the sink, this name will be the `fiware-service` found on the headers of the first request incoming to the sink.

* All the other data models will take the name of the database from the agent properties configuration file as usual.

[Top](#top)

#### <a name="section1.2.2"></a>PostgreSQL schemas naming conventions
A schema named as the notified `fiware-service` header value (or, in absence of such a header, the defaulted value for the FIWARE service) is created (if not existing yet).

It must be said [PostgreSQL only accepts](https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) alphanumeric characters and the underscore (`_`). This leads to  certain [encoding](#section2.3.4) is applied depending on the `enable_encoding` configuration parameter.

PostgreSQL [schemas name length](http://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) is limited to 63 characters.

* Data model by entity database schema (`data_model=dm-by-entity-database-schema`). For this datamodel the name of the schema will be auto generated by the sink, this name will be the `fiware-servicePath` found on the headers of the first request to store.

* All the other data models will take the name of the schema from the notified `fiware-service` as usual.

[Top](#top)

#### <a name="section1.2.3"></a>PostgreSQL tables naming conventions
The name of these tables depends on the configured data model (see the [Configuration](#section2.1) section for more details):

* Data model by service path (`data_model=dm-by-service-path`). As the data model name denotes, the notified FIWARE service path (or the configured one as default in [`NGSIRestHandler`](./ngsi_rest_handler.md)) is used as the name of the table. This allows the data about all the NGSI entities belonging to the same service path is stored in this unique table. The only constraint regarding this data model is the FIWARE service path cannot be the root one (`/`).
* Data model by entity (`data_model=dm-by-entity`). For each entity, the notified/default FIWARE service path is concatenated to the notified entity ID and type in order to compose the table name. If the FIWARE service path is the root one (`/`) then only the entity ID and type are concatenated.
* Data model by entity database schema (`data_model=dm-by-entity-database-schema`). Same as Data model by entity (`data_model=dm-by-entity`).
* Data model by entity database schema (`data_model=dm-by-entity-database`). Same as Data model by entity (`data_model=dm-by-entity`).
* Data model by entity type (`data_model=dm-by-entity-type`). For each entity, the notified/default FIWARE service path is concatenated to the notified entity type in order to compose the table name. The concatenation character is `_` (underscore). If the FIWARE service path is the root one (`/`) then only the entity type is concatenated.

It must be said [PostgreSQL only accepts](https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) alphanumeric characters and the underscore (`_`). This leads to  certain [encoding](#section2.3.4) is applied depending on the `enable_encoding` configuration parameter.

PostgreSQL [tables name length](http://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) is limited to 63 characters.

The following table summarizes the table name composition (old encoding):

| FIWARE service path | `dm-by-service-path` | `dm-by-entity` | `dm-by-entity-type` |
|---|---|---|---|
| `/` | N/A | `<entityId>_<entityType>` | `<entityType>` |
| `/<svcPath>` | `<svcPath>` | `<svcPath>_<entityId>_<entityType>` | `<svcPath>_<entityType>` |

Using the new encoding:

| FIWARE service path | `dm-by-service-path` | `dm-by-entity` | `dm-by-entity-type` |
|---|---|---|---|
| `/` | `x002f` | `x002fxffff<entityId>xffff<entityType>` | `x002fxffff<entityType>` |
| `/<svcPath>` | `x002f<svcPath>` | `x002f<svcPath>xffff<entityId>xffff<entityType>` |`x002f<svcPath>xffff<entityType>` |

Please observe the concatenation of entity ID and type is already given in the `notified_entities`/`grouped_entities` header values (depending on using or not the grouping rules, see the [Configuration](#section2.1) section for more details) within the `NGSIEvent`.


## <a name="section2"></a>Administration guide
Please refear to [`NGSIPostgreSQLSink`](/ngsi_postgresql_sink.md) since all administration options about PostgreSQLSink applies to PostGISSink.

### <a name="section2.1"></a>Configuration
`NGSIPostgrisSink` can be configured through the same parameters as `NGSIPostgreSQLSink` except for postgis data_model functions

| Parameter | Mandatory | Default value | Comments |
|---|---|---|---|
| . | . | . | . |
| . | . |same as NGSIPostgreSQLSink| . |
| . | . | . | . |
| data\_model | no | dm-by-entity | <i>dm-by-service-path</i> or <i>dm-by-entity</i> or <i>dm-by-entity-type</i> or  <i>dm-by-entity-database</i> or <i>dm-by-entity-database-schema</i>.
| . | . | . | . |


## <a name="section3"></a>Programmers guide
Please refear to [`NGSIPostgreSQLSink`](/ngsi_postgresql_sink.md) since all programing details about PostgreSQLSink applies to PostGISSink.


## <a name="section4"></a>Native types

Regarding the specific data stored within the above table, if `attr_native_types` parameter is set to `true` then attribute is inserted using its native type (according with the following table), if `false` then will be stringify. 

Type json     | Type PostGreSQL/POSTGIS
------------- | --------------------------------------- 
string        | text
number        | double, precision, real, others (numeric, decimal)
boolean       | boolean (TRUE, FALSE, NULL)
DateTime      | timestamp, timestamp with time zone, timestamp without time zone
json          | text o json - it`s treated as String
null          | NULL

This only applies to Column mode.
